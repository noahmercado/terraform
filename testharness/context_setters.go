package testharness

import (
	"fmt"

	"github.com/hashicorp/terraform/terraform"
	"github.com/hashicorp/terraform/tfdiags"
	"github.com/zclconf/go-cty/cty"
)

// A contextSetter is something passed to the first argument of a "describe"
// call in a spec to establish what any sub-testers are testing. Internally,
// these objects produce derived Context objects representing what the user
// passed in.

// Method AppendContext must append zero or more new contexts to the given
// slice (which may be nil) and return the result. Each context appended
// represents a distinct context in which to run any downstream tests.
type contextSetter interface {
	AppendContexts(parent *Context, subject *Subject, ctxs []*Context) ([]*Context, tfdiags.Diagnostics)
}

// contextSetter implementations
var (
	_ contextSetter = simpleContextSetter("")
	_ contextSetter = (*resourceContextSetter)(nil)
)

// A simpleContextSetter is a contextSetter that actually provides no
// additional contextual objects, but records the user-supplied name of
// something being tested.
type simpleContextSetter string

func (s simpleContextSetter) AppendContexts(parent *Context, subject *Subject, ctxs []*Context) ([]*Context, tfdiags.Diagnostics) {
	return append(ctxs, parent.WithNameSuffix(string(s))), nil
}

// A resourceContextSetter is a contextSetter that uses a resource from the
// state as its context.
type resourceContextSetter struct {
	Addr *terraform.ResourceAddress

	DefRange tfdiags.SourceRange
}

func (s *resourceContextSetter) AppendContexts(parent *Context, subject *Subject, ctxs []*Context) ([]*Context, tfdiags.Diagnostics) {
	var diags tfdiags.Diagnostics

	// FIXME: Check if a resource with the given address is defined _at all_
	// and return an error if not. When we do this, we must handle the special
	// case where the resource _is_ defined but has count = 0, in which case
	// that is not an error but rather we just generate no child contexts
	// at all.

	filter := &terraform.StateFilter{
		State: subject.state,
	}
	// The StateFilter interface is weird: it expects ResourceAddress _strings_
	// which it parses itself, rather than letting the caller do its own
	// validation. Since we already parsed and validated our resource address,
	// we'll need to stringify it here and let this function re-parse it. :/
	results, err := filter.Filter(s.Addr.String())
	if err != nil {
		// The only possible error is an invalid address, which should never
		// happen because we're passing in a pre-validated address here.
		// Thus we won't go to any unusual effort to make this a user-friendly
		// diagnostic.
		diags = diags.Append(err)
		return ctxs, diags
	}

	for _, result := range results {
		// Again, for some reason the StateFilter interface deals in strings
		// rather than ResourceAddress objects, so once again we end up
		// redundantly round-tripping through a string. :(
		addr, err := terraform.ParseResourceAddress(result.Address)
		if err != nil {
			// Should never happen because this address was just handed
			// to us by Terraform core
			panic(fmt.Errorf("invalid resource address generated by Terraform core: %s", err))
		}

		var inst *terraform.InstanceState
		switch tr := result.Value.(type) {
		case *terraform.InstanceState:
			inst = tr
		default:
			// should never happen, but if it does we'll ignore it since
			// it's presumably some new type of thing in state.
			continue
		}

		// TODO: convert inst into a cty.Value representing the instance,
		// which we can then place in the context for downstream test
		// code to use.
		_ = inst
		ctxs = append(ctxs, parent.WithResource(addr, cty.DynamicVal))
	}

	return ctxs, diags
}
